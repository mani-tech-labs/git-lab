Centralized Version Control System:
This is a legacy version control system where version control happens on centralized servers. Since it's centralized, developers depend on the central server for their commits and updates. While it's easy to maintain a single server, there is a risk of a single point of failure. If developers cannot connect to the server, their work is blocked. To overcome these limitations, Linus Torvalds, the creator of Linux, officially introduced Git on April 7th, 2005.

Distributed Version Control System (Git):
-----------------------------------------
In this system, every developer can have their own copy of the code from the main (remote) server. They can make changes in their local copies and, once ready, push the changes to the remote server (main branch). Once code is pushed to the remote origin, those commits are stored on the remote server. Developers can control which commits they share (to avoid unnecessary commits :P). Other developers can do the same, and finally, the working/product code will be kept in the remote origin/main branch. An approval system can be in place to avoid commit mistakes and protect the main branch. If two developers make changes to the same line, a conflict arises and must be resolved manually. Before pushing, every developer should update their local code with the latest changes from the remote origin.

Let's explore commands:
git init    : Initializes Git in your project (like installing a CCTV camera in the project :P). For new local projects, use this; for existing projects, you typically clone repos.

git clone <repo url>

Ex: git clone https://github.com/mani-tech-labs/shell-scripting-projects.git

git status  : Shows the status of your current working directory—modified files, files to be staged, files to be committed, etc. It also suggests helpful commands.

git log     : Displays all commits made by all users. Option -p shows a detailed log, including changes made to files.

git add     : Adds a modified or new file to the staging area.

git add .   : Adds all modified files to the staging area.

git restore --staged <filename> : Reverts a staged file back to the modified state.

git restore --staged .  : Reverts all staged files back to the modified state.

git restore <filename>  : Discards modifications made to a file.

git commit -m "msg"     : Commits changes to your local repository.

git remote -v           : Lists all remotes connected to your local repo. The URL shows where the repo is hosted (GitHub/GitLab).

git remote remove <remote-name>

Ex: git remote remove origin   # Removes the 'origin' remote

git remote add origin <remote-url>

Ex: git remote add origin https://github.com/mani-tech-labs/git-lab.git

Tip: In VS Code, when you add a new GitHub origin, authentication is handled via browser, since GitHub and VS Code are both owned by Microsoft.

git push origin main    : Pushes your local repo changes to origin/main (the remote repo :)

git log     : Lists all previous commits. Option --oneline lists commits in one line. Option --decorate adds extra information and visual annotations.

git log <branch-name>   : Displays commit logs for the specified branch

git branch  : Lists all branches. An arrow or highlight shows your current branch.

git branch <branch-name>    : To create a new branch

git checkout <branch-name>  : To switch to mentioned branch

git merge <branch-name>     : To merge the mentioned branch.

git cherry-pick <commit-hash> : To pick the specific commit from other branch

git cherry-pick <commit1> <commit2> .. : To pick multiple commits

Note: git cherry-pick is used to apply a specific commit to the current branch. It is mainly used to bring commits from another branch without merging everything, but it can also be useful within the same branch. For example, if a commit was reverted but later you want it back, you can cherry-pick that commit to reapply its changes. Similarly, if you need to duplicate a commit later in the history, cherry-pick can create a fresh copy of it. This makes cherry-pick a flexible tool for selectively reusing commits.
Clone Vs Fork

git rebase  : Used to merge with linear commit history, means oder of commit history

git fetch   : It will fetch and show the latest changes from remote, it will not merge with the local copy

git fetch vs git pull   : fetch will Shows latest changes and pull updates the local copy with latest code from remote repo

git commit --amend  : To add to changes to commit, which is already done

.git        : It will be create during git init, it will used for tracking your project and contains all useful info like files, remote origin details, commit hashes etc. 

.gitignore  : If you don't to send any (sensitive) file to remote repo, you can add the file to .gitignore

git pre-commit hooks    : Actions that are taken by git before commit
Ex: you can configure before firing commit command, like execute the script before commit command, like sometimes you forget somethings or check which you can automate using pre-hooks

git post-commit hooks   : Actions that are taken by git after commit
Ex: If you want to perform or automate any action after commit it will useful.

Clone → makes a local copy of a repository on your machine. You can read, modify, and commit locally, but it’s still connected to the original repo (remote). Think of it like downloading a working copy.

Fork → makes a copy of the entire repository under your GitHub account. It lives on GitHub, not just your machine. You can then clone your fork locally, make changes, and create a pull request to suggest changes back to the original project. Think of it like copying a project into your own GitHub workspace.

What is webhook : Suppose in your CICD pipeline say after python you want GitHub to perform some actions, or after commit or add or push you want to perform some GitHub action, you can create a hook in GitHub or select a hook from GitHub and configure it will run accordingly.

git stash   : If you want to save changes temporarily then this can be used, after if you want changes back than hit git stash pop

git merge conflicts : Can be done manually with good collborations with other developers







